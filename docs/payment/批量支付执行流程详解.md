# 批量支付执行流程详解

## 文档信息
| 项目 | 内容 |
|------|------|
| **文档名称** | 批量支付执行流程详解 |
| **文档版本** | v1.0 |
| **创建日期** | 2025-01-15 |
| **基准文档** | payment.yml v2.0, 支付模块需求设计文档 v1.5 |
| **相关用例** | UC-PM-003 执行支付操作 |

## 目录
- [1. 概述](#1-概述)
- [2. 九步支付流程](#2-九步支付流程)
- [3. 核心类与方法](#3-核心类与方法)
- [4. 时序图](#4-时序图)
- [5. 异常处理](#5-异常处理)
- [6. 测试用例](#6-测试用例)

## 1. 概述

### 1.1 功能说明
批量支付执行功能（executeBatchPayment）是支付模块的核心功能之一，支持经销商选择一个或多个待支付支付单，通过同一支付渠道进行合并支付。

### 1.2 设计原则
- **严格的流程控制**: 支付流程分为9个明确的步骤，按顺序执行
- **完整的验证机制**: 在执行支付前进行多层验证，确保支付安全
- **清晰的职责划分**: 应用服务层负责流程编排，领域层负责业务逻辑
- **事务一致性**: 整个支付流程在一个事务中执行，确保数据一致性

### 1.3 支持场景
1. **单支付单支付**: 支付单列表包含一个支付单
2. **多支付单合并支付**: 支付单列表包含多个支付单，使用同一渠道合并支付
3. **部分金额支付**: 每个支付单可以支付部分金额，支持分批支付
4. **信用还款支付**: 支持信用还款类型的支付单（paymentType=CREDIT_REPAYMENT）

---

## 2. 九步支付流程

### 步骤1: 获取支付渠道

**目的**: 根据支付命令中的渠道类型，找到对应的支付渠道服务实现。

**实现**:
```java
IPaymentChannelService channelService = findChannelService(command.getPaymentChannel());
```

**验证**:
- 渠道服务必须存在
- 渠道类型必须匹配

**异常**: 如果找不到对应的渠道服务，抛出 `PaymentException("支付渠道不可用")`

---

### 步骤2: 验证支付渠道可用

**目的**: 验证支付单的合法性和渠道的可用性。

**验证项**:

1. **支付单存在性验证**
   ```java
   List<PaymentAggregate> payments = paymentRepository.findByIds(paymentIds);
   if (payments.size() != paymentIds.size()) {
       throw new PaymentException("部分支付单不存在");
   }
   ```

2. **经销商一致性验证**
   ```java
   Set<String> resellerIds = payments.stream()
           .map(PaymentAggregate::getResellerId)
           .collect(Collectors.toSet());
   if (resellerIds.size() != 1) {
       throw new PaymentException("所有支付单必须属于同一经销商");
   }
   ```

3. **渠道可用性验证**
   ```java
   if (!channelService.isAvailable(resellerId)) {
       throw new PaymentException("支付渠道对当前经销商不可用");
   }
   ```

**业务规则**:
- 所有支付单必须存在于数据库中
- 所有支付单必须属于同一个经销商
- 支付渠道必须对该经销商可用

---

### 步骤3: 计算支付总金额

**目的**: 计算本次支付的总金额，用于后续的渠道支付请求。

**实现**:
```java
BigDecimal totalAmount = command.getPaymentItems().stream()
        .map(ExecutePaymentCommand.PaymentItem::getAmount)
        .reduce(BigDecimal.ZERO, BigDecimal::add);
```

**日志输出**:
```
总支付金额: 30000.00
```

---

### 步骤4: 验证该经销商该金额可支付

**目的**: 验证支付单状态和金额的合法性，以及渠道对该金额的支持。

**验证项**:

1. **支付单状态验证**
   ```java
   for (PaymentAggregate payment : payments) {
       if (!payment.canPay()) {
           throw new PaymentException("支付单 " + payment.getCode() + " 当前状态不允许支付");
       }
   }
   ```
   - 支付单状态必须为 `UNPAID` 或 `PARTIAL_PAID`
   - 待支付金额必须大于0
   - 支付单未被冻结

2. **支付金额验证**
   ```java
   BigDecimal pendingAmount = payment.getPaymentAmount()
           .subtract(payment.getPaidAmount());
   if (item.getAmount().compareTo(pendingAmount) > 0) {
       throw new PaymentException("支付单 " + payment.getCode() + " 的支付金额超过待支付金额");
   }
   ```

3. **渠道金额支持验证**
   ```java
   if (!channelService.supportsAmountForReseller(resellerId, totalAmount)) {
       throw new PaymentException("支付渠道不支持当前经销商的该金额支付");
   }
   ```

**业务规则**:
- 每个支付单的本次支付金额 ≤ 待支付金额
- 支付渠道必须支持该经销商的该金额支付（考虑渠道限额、经销商信用额度等）

---

### 步骤5: 创建支付明细

**目的**: 为每个参与支付的支付单创建支付流水记录。

**实现**:
```java
for (int i = 0; i < payments.size(); i++) {
    PaymentAggregate payment = payments.get(i);
    ExecutePaymentCommand.PaymentItem item = command.getPaymentItems().get(i);
    
    // 创建支付流水（状态为PROCESSING，渠道信息尚未获取）
    payment.executePayment(
            command.getPaymentChannel(),
            item.getAmount(),
            null,  // channelTransactionNumber 将在步骤8回写
            null   // channelPaymentRecordId 将在步骤8回写
    );
}
```

**流水状态**: `PROCESSING` (处理中)

**重要说明**:
- 此时流水已在聚合根内存中创建，但尚未持久化
- 渠道交易号和渠道支付记录ID暂时为null，将在步骤8回写
- 每个支付单对应一个独立的支付流水

---

### 步骤6: 创建渠道支付请求

**目的**: 构建渠道支付请求命令对象。

**实现**:
```java
CreatePaymentRequestCommand createPaymentRequestCommand = 
    CreatePaymentRequestCommand.builder()
            .totalAmount(totalAmount)
            .resellerId(resellerId)
            .build();
```

**参数说明**:
- `totalAmount`: 支付总金额（步骤3计算得出）
- `resellerId`: 经销商ID（步骤2验证得出）

---

### 步骤7: 发起渠道支付

**目的**: 调用支付渠道服务，发起实际的支付请求。

**实现**:
```java
PaymentRequestResponse paymentRequest = 
    channelService.createPaymentRequest(createPaymentRequestCommand);
```

**返回值**:
```java
public class PaymentRequestResponse {
    private String channelPaymentRecordId;  // 渠道支付记录ID
    private String channelTransactionNumber; // 渠道交易号
}
```

**日志输出**:
```
渠道支付请求创建成功，渠道交易号: CHN_TXN_001, 渠道支付记录ID: CHN_RECORD_001
```

**说明**:
- `channelPaymentRecordId`: 渠道系统的支付记录唯一标识，在创建支付时即返回
- `channelTransactionNumber`: 渠道交易号，有些渠道在创建时即返回，有些在回调时返回

---

### 步骤8: 获得支付请求结果，并回写到所有支付明细中

**目的**: 将渠道返回的交易信息回写到每个支付流水中。

**实现**:
```java
for (PaymentAggregate payment : payments) {
    // 获取该支付单最新创建的支付流水
    PaymentTransaction latestTransaction = payment.getLatestProcessingTransaction();
    if (latestTransaction != null) {
        // 回写渠道交易号和渠道支付记录ID
        latestTransaction.setChannelTransactionNumber(paymentRequest.getChannelTransactionNumber());
        latestTransaction.setChannelPaymentRecordId(paymentRequest.getChannelPaymentRecordId());
    }
}
```

**getLatestProcessingTransaction()方法**:
```java
/**
 * 获取最新的处理中的支付流水
 * 从后往前查找，找到第一个状态为PROCESSING且类型为PAYMENT的流水
 */
public PaymentTransaction getLatestProcessingTransaction() {
    if (this.transactions == null || this.transactions.isEmpty()) {
        return null;
    }
    
    for (int i = this.transactions.size() - 1; i >= 0; i--) {
        PaymentTransaction transaction = this.transactions.get(i);
        if (transaction != null 
                && TransactionType.PAYMENT.equals(transaction.getTransactionType())
                && TransactionStatus.PROCESSING.equals(transaction.getTransactionStatus())) {
            return transaction;
        }
    }
    return null;
}
```

**业务意义**:
- 将渠道返回的交易标识关联到每个支付流水
- 用于后续的支付回调匹配和对账查询

---

### 步骤9: 持久化支付明细

**目的**: 将所有支付单及其流水持久化到数据库。

**实现**:
```java
for (PaymentAggregate payment : payments) {
    paymentRepository.save(payment);
    log.info("支付单 {} 及其流水已持久化", payment.getCode());
}
```

**持久化内容**:
- 支付单状态更新（UNPAID → PAYING）
- 新创建的支付流水记录
- 流水中包含的渠道交易信息

**事务保证**:
- 整个executeBatchPayment方法标注了 `@Transactional`
- 如果持久化失败，整个事务回滚，支付流程不会生效

---

## 3. 核心类与方法

### 3.1 PaymentApplicationServiceImpl

**职责**: 支付应用服务，负责批量支付流程的编排。

**关键方法**:
```java
@Service
@Transactional(rollbackFor = Exception.class)
public String executeBatchPayment(ExecutePaymentCommand command) {
    // 9步支付流程实现
    // ...
    return paymentRequest.getChannelPaymentRecordId();
}
```

**依赖**:
- `IPaymentRepository`: 支付单仓储接口
- `List<IPaymentChannelService>`: 支付渠道服务列表
- `ApplicationEventPublisher`: 事件发布器（可选）

---

### 3.2 PaymentAggregate

**职责**: 支付单聚合根，封装支付相关的业务逻辑。

**关键方法**:

1. **executePayment**: 创建支付流水
   ```java
   public PaymentTransaction executePayment(
           PaymentChannel paymentChannel,
           BigDecimal amount,
           String channelTransactionNumber,
           String channelPaymentRecordId) {
       // 创建支付流水
       PaymentTransaction transaction = PaymentTransaction.builder()
               .paymentId(this.id)
               .transactionType(TransactionType.PAYMENT)
               .transactionStatus(TransactionStatus.PROCESSING)
               .transactionAmount(amount)
               .paymentChannel(paymentChannel)
               .channelTransactionNumber(channelTransactionNumber)
               .channelPaymentRecordId(channelPaymentRecordId)
               .build();

       this.transactions.add(transaction);
       this.paymentStatus = PaymentStatus.PAYING;

       return transaction;
   }
   ```

2. **canPay**: 判断是否允许支付
   ```java
   public boolean canPay() {
       return (PaymentStatus.UNPAID.equals(this.paymentStatus) 
               || PaymentStatus.PARTIAL_PAID.equals(this.paymentStatus))
               && getPendingAmount().compareTo(BigDecimal.ZERO) > 0;
   }
   ```

3. **getLatestProcessingTransaction**: 获取最新的处理中流水
   ```java
   public PaymentTransaction getLatestProcessingTransaction() {
       // 见步骤8的实现
   }
   ```

---

### 3.3 ExecutePaymentCommand

**职责**: 执行支付命令，封装批量支付的输入参数。

**字段**:
```java
@Data
@Builder
public class ExecutePaymentCommand {
    private List<PaymentItem> paymentItems;  // 支付单项列表
    private PaymentChannel paymentChannel;   // 支付渠道
    private String operatorId;               // 操作人ID
    private String operatorName;             // 操作人姓名
    
    @Data
    @Builder
    public static class PaymentItem {
        private String paymentId;      // 支付单ID（主键）
        private BigDecimal amount;     // 本次支付金额
    }
}
```

---

### 3.4 IPaymentChannelService

**职责**: 支付渠道服务接口，定义渠道的通用操作。

**关键方法**:
```java
public interface IPaymentChannelService {
    PaymentChannel getChannelType();
    
    boolean isAvailable(String resellerId);
    
    boolean supportsAmountForReseller(String resellerId, BigDecimal amount);
    
    PaymentRequestResponse createPaymentRequest(CreatePaymentRequestCommand command);
}
```

**实现类**:
- `OnlinePaymentChannelService`: 线上支付渠道
- `WalletPaymentChannelService`: 钱包支付渠道
- `WireTransferChannelService`: 电汇支付渠道
- `CreditAccountChannelService`: 信用账户渠道

---

## 4. 时序图

```
经销商     Controller     ApplicationService     PaymentAggregate     ChannelService     Repository
  |             |                   |                    |                  |               |
  |--批量支付-->|                   |                    |                  |               |
  |             |                   |                    |                  |               |
  |             |--executeBatch---->|                    |                  |               |
  |             |                   |                    |                  |               |
  |             |                   |--步骤1:获取渠道--->|                  |               |
  |             |                   |                    |                  |               |
  |             |                   |--步骤2:查询支付单------------------------>|------------->|
  |             |                   |<-------------------返回支付单列表---------|<-------------|
  |             |                   |--验证经销商一致性-->|                  |               |
  |             |                   |--验证渠道可用------|----------------->|               |
  |             |                   |<------------------|--返回true---------|               |
  |             |                   |                    |                  |               |
  |             |                   |--步骤3:计算总金额-->|                  |               |
  |             |                   |                    |                  |               |
  |             |                   |--步骤4:验证状态--->|                  |               |
  |             |                   |--canPay()--------->|                  |               |
  |             |                   |<---返回true--------|                  |               |
  |             |                   |--验证金额支持------|----------------->|               |
  |             |                   |<------------------|--返回true---------|               |
  |             |                   |                    |                  |               |
  |             |                   |--步骤5:创建流水--->|                  |               |
  |             |                   |--executePayment--->|                  |               |
  |             |                   |<---返回流水--------|                  |               |
  |             |                   |                    |                  |               |
  |             |                   |--步骤6:构建请求--->|                  |               |
  |             |                   |                    |                  |               |
  |             |                   |--步骤7:发起支付----|----------------->|               |
  |             |                   |<------------------|--返回渠道信息-----|               |
  |             |                   |                    |                  |               |
  |             |                   |--步骤8:回写信息--->|                  |               |
  |             |                   |--getLatestTxn----->|                  |               |
  |             |                   |--setChannel------->|                  |               |
  |             |                   |                    |                  |               |
  |             |                   |--步骤9:持久化------|------------------|-------------->|
  |             |                   |<-------------------|------------------|<--------------|
  |             |                   |                    |                  |               |
  |             |<---返回记录ID-----|                    |                  |               |
  |             |                   |                    |                  |               |
  |<--返回结果--|                   |                    |                  |               |
  |             |                   |                    |                  |               |
```

---

## 5. 异常处理

### 5.1 异常类型

| 异常类型 | 触发条件 | 处理方式 |
|---------|---------|---------|
| `PaymentException` | 业务规则验证失败 | 回滚事务，返回错误信息 |
| `IllegalArgumentException` | 参数验证失败 | 回滚事务，返回错误信息 |
| `DataAccessException` | 数据库操作失败 | 回滚事务，返回系统错误 |

### 5.2 常见异常场景

1. **支付渠道不可用**
   ```
   步骤1失败: PaymentException("支付渠道不可用: 线上支付")
   ```

2. **支付单不存在**
   ```
   步骤2失败: PaymentException("部分支付单不存在")
   ```

3. **经销商不一致**
   ```
   步骤2失败: PaymentException("所有支付单必须属于同一经销商")
   ```

4. **渠道对经销商不可用**
   ```
   步骤2失败: PaymentException("支付渠道对当前经销商不可用")
   ```

5. **支付单状态不允许支付**
   ```
   步骤4失败: PaymentException("支付单 PAY-001 当前状态不允许支付")
   ```

6. **支付金额超过待支付金额**
   ```
   步骤4失败: PaymentException("支付单 PAY-001 的支付金额超过待支付金额")
   ```

7. **渠道不支持该金额**
   ```
   步骤4失败: PaymentException("支付渠道不支持当前经销商的该金额支付")
   ```

### 5.3 事务回滚

- 整个 `executeBatchPayment` 方法标注了 `@Transactional(rollbackFor = Exception.class)`
- 任何步骤抛出异常，都会导致整个事务回滚
- 回滚后，所有数据库操作都不会生效，支付单状态和流水记录不会被创建

---

## 6. 测试用例

### 6.1 正常流程测试

**测试场景**: 两个支付单合并支付，正常流程

**测试数据**:
```java
// 支付单1: 10000元
PaymentAggregate payment1 = createPayment("PAY-001", "10000.00", "RESELLER-001");

// 支付单2: 20000元
PaymentAggregate payment2 = createPayment("PAY-002", "20000.00", "RESELLER-001");

// 执行命令
ExecutePaymentCommand command = ExecutePaymentCommand.builder()
        .paymentChannel(PaymentChannel.ONLINE_PAYMENT)
        .paymentItems(Arrays.asList(
                new PaymentItem("1", new BigDecimal("10000.00")),
                new PaymentItem("2", new BigDecimal("20000.00"))
        ))
        .build();
```

**预期结果**:
- 返回渠道支付记录ID
- payment1和payment2状态都变为PAYING
- payment1和payment2各有一条流水，状态为PROCESSING
- 两条流水的channelTransactionNumber和channelPaymentRecordId相同

**验证代码**:
```java
@Test
void testExecuteBatchPayment_Success() {
    // Given
    // ...
    
    // When
    String channelRecordId = paymentApplicationService.executeBatchPayment(command);
    
    // Then
    assertNotNull(channelRecordId);
    assertEquals("MOCK_RECORD_001", channelRecordId);
    assertEquals(PaymentStatus.PAYING, payment1.getPaymentStatus());
    assertEquals(PaymentStatus.PAYING, payment2.getPaymentStatus());
    assertEquals(1, payment1.getTransactions().size());
    assertEquals(1, payment2.getTransactions().size());
    
    PaymentTransaction txn1 = payment1.getTransactions().get(0);
    PaymentTransaction txn2 = payment2.getTransactions().get(0);
    assertEquals(txn1.getChannelTransactionNumber(), txn2.getChannelTransactionNumber());
    assertEquals(txn1.getChannelPaymentRecordId(), txn2.getChannelPaymentRecordId());
}
```

---

### 6.2 不同经销商异常测试

**测试场景**: 两个支付单属于不同经销商

**测试数据**:
```java
payment1.setResellerId("RESELLER-001");
payment2.setResellerId("RESELLER-002");  // 不同的经销商
```

**预期结果**:
- 抛出 `PaymentException`
- 异常消息: "所有支付单必须属于同一经销商"
- 没有任何支付单被保存

**验证代码**:
```java
@Test
void testExecuteBatchPayment_DifferentReseller() {
    // Given
    payment2.setResellerId("RESELLER-002");
    
    // When & Then
    PaymentException exception = assertThrows(PaymentException.class, () -> {
        paymentApplicationService.executeBatchPayment(command);
    });
    
    assertEquals("所有支付单必须属于同一经销商", exception.getMessage());
    verify(paymentRepository, never()).save(any(PaymentAggregate.class));
}
```

---

### 6.3 支付单状态不允许支付测试

**测试场景**: 支付单状态为FROZEN（冻结）

**测试数据**:
```java
payment1.setPaymentStatus(PaymentStatus.FROZEN);
```

**预期结果**:
- 抛出 `PaymentException`
- 异常消息包含: "当前状态不允许支付"
- 没有任何支付单被保存

**验证代码**:
```java
@Test
void testExecuteBatchPayment_PaymentNotAllowed() {
    // Given
    payment1.setPaymentStatus(PaymentStatus.FROZEN);
    
    // When & Then
    PaymentException exception = assertThrows(PaymentException.class, () -> {
        paymentApplicationService.executeBatchPayment(command);
    });
    
    assertTrue(exception.getMessage().contains("当前状态不允许支付"));
    verify(paymentRepository, never()).save(any(PaymentAggregate.class));
}
```

---

### 6.4 单支付单支付测试

**测试场景**: 只有一个支付单进行支付

**测试数据**:
```java
ExecutePaymentCommand command = ExecutePaymentCommand.builder()
        .paymentChannel(PaymentChannel.WALLET_PAYMENT)
        .paymentItems(Arrays.asList(
                new PaymentItem("1", new BigDecimal("10000.00"))
        ))
        .build();
```

**预期结果**:
- 返回渠道支付记录ID
- payment1状态变为PAYING
- payment1有一条流水，渠道为WALLET_PAYMENT

**验证代码**:
```java
@Test
void testExecuteBatchPayment_SinglePayment() {
    // Given
    // ...
    
    // When
    String channelRecordId = paymentApplicationService.executeBatchPayment(command);
    
    // Then
    assertNotNull(channelRecordId);
    assertEquals("WALLET_RECORD_001", channelRecordId);
    assertEquals(PaymentStatus.PAYING, payment1.getPaymentStatus());
    assertEquals(1, payment1.getTransactions().size());
    assertEquals(PaymentChannel.WALLET_PAYMENT, 
            payment1.getTransactions().get(0).getPaymentChannel());
}
```

---

### 6.5 渠道交易号正确回写测试

**测试场景**: 验证渠道返回的交易信息正确回写到流水

**预期结果**:
- 流水的channelTransactionNumber和channelPaymentRecordId被正确设置
- 与mock返回的值一致

**验证代码**:
```java
@Test
void testExecuteBatchPayment_ChannelTransactionNumber() {
    // Given
    when(channelService.createPaymentRequest(any()))
            .thenReturn(new PaymentRequestResponse(
                    "MOCK_RECORD_123", "MOCK_CHANNEL_TXN_123"));
    
    // When
    String channelRecordId = paymentApplicationService.executeBatchPayment(command);
    
    // Then
    PaymentTransaction transaction = payment1.getTransactions().get(0);
    assertEquals("MOCK_CHANNEL_TXN_123", transaction.getChannelTransactionNumber());
    assertEquals("MOCK_RECORD_123", transaction.getChannelPaymentRecordId());
    assertEquals("MOCK_RECORD_123", channelRecordId);
}
```

---

## 7. 性能考虑

### 7.1 批量查询优化

**问题**: 如果逐个查询支付单，会产生N+1查询问题

**解决方案**: 使用批量查询
```java
List<PaymentAggregate> payments = paymentRepository.findByIds(paymentIds);
```

**MyBatis-Plus实现**:
```java
@Override
public List<PaymentAggregate> findByIds(List<String> ids) {
    return lambdaQuery()
            .in(PaymentEntity::getId, ids)
            .list()
            .stream()
            .map(this::toAggregate)
            .collect(Collectors.toList());
}
```

---

### 7.2 批量保存优化

**当前实现**: 逐个保存
```java
for (PaymentAggregate payment : payments) {
    paymentRepository.save(payment);
}
```

**优化建议**: 使用批量保存（如果Repository支持）
```java
paymentRepository.saveAll(payments);
```

---

### 7.3 事务范围优化

**当前**: 整个executeBatchPayment在一个事务中

**优化建议**: 
- 对于非关键的日志记录，可以使用异步处理
- 对于大量支付单的情况，可以考虑分批处理

---

## 8. 安全考虑

### 8.1 权限验证

**建议**: 在Controller层验证经销商权限
```java
// 验证请求的支付单是否属于当前登录的经销商
for (PaymentItem item : ro.getPaymentItems()) {
    String paymentId = convertToPaymentId(item.getPaymentCode());
    if (!belongsToReseller(paymentId, currentResellerId)) {
        throw new UnauthorizedException("无权操作该支付单");
    }
}
```

---

### 8.2 防重复提交

**问题**: 用户可能重复点击支付按钮

**解决方案**: 
1. 前端防抖处理
2. 后端使用幂等性令牌
3. 检查支付单状态（如果已经是PAYING，拒绝再次支付）

---

### 8.3 金额验证

**当前**: 已实现金额不超过待支付金额的验证

**建议**: 增加金额精度验证
```java
// 验证金额不超过6位小数
if (amount.scale() > 6) {
    throw new IllegalArgumentException("支付金额最多保留6位小数");
}
```

---

## 9. 总结

### 9.1 核心优势

1. **流程清晰**: 9个步骤各司其职，易于理解和维护
2. **验证完整**: 多层验证机制，确保支付安全
3. **职责分明**: 应用层编排，领域层逻辑，基础设施层实现
4. **事务一致**: 整个流程在一个事务中，保证数据一致性
5. **可扩展性**: 易于支持新的支付渠道和支付场景

### 9.2 改进建议

1. 增加批量保存优化
2. 增加防重复提交机制
3. 增加支付超时处理
4. 增加支付限流保护
5. 增加详细的审计日志

### 9.3 相关文档

- [payment.yml](./payment.yml) - DDD设计规范
- [支付模块需求设计.md](./支付模块需求设计.md) - 需求文档
- [支付模块用例模型.md](./支付模块用例模型.md) - 用例模型
- [接口使用说明.md](./接口使用说明.md) - 接口使用指南
