# 支付模块接口使用说明

## 文档信息
| 项目 | 内容 |
|------|------|
| **文档名称** | 支付模块接口使用说明 |
| **文档版本** | v1.0 |
| **创建日期** | 2025-01-15 |
| **基准文档** | payment.yml v2.0, 支付模块需求设计文档 v1.5 |

## 目录
- [1. 概述](#1-概述)
- [2. 内部Java接口](#2-内部java接口)
- [3. 外部REST接口](#3-外部rest接口)
- [4. 使用示例](#4-使用示例)

## 1. 概述

支付模块提供两类接口：

### 1.1 内部Java接口（系统间调用）
- **接口名称**: `IPaymentInternalService`
- **使用方式**: Spring依赖注入
- **调用方**: 订单系统、信用管理系统等内部模块
- **方法**:
  - `createPayment()` - 创建支付单
  - `executeRefund()` - 执行退款

### 1.2 外部REST接口（前端调用）
- **控制器**: `PaymentController`
- **基础路径**: `/api/v1/payments`
- **调用方**: 前端应用
- **端点**:
  - `POST /batch-pay` - 批量支付
  - `GET /available-channels` - 查询可用支付渠道

---

## 2. 内部Java接口

### 2.1 创建支付单接口

#### 接口定义
```java
package com.bytz.modules.cms.payment.application;

public interface IPaymentInternalService {
    /**
     * 创建支付单
     * @param command 创建支付单命令
     * @return 支付单聚合根
     */
    PaymentAggregate createPayment(CreatePaymentCommand command);
}
```

#### 使用场景
1. **订单系统**：订单创建后，调用此接口创建支付单
2. **信用管理系统**：创建信用还款支付单

#### 参数说明

**CreatePaymentCommand**:
```java
CreatePaymentCommand.builder()
    .orderId("ORDER123456")              // 订单号（必填）
    .resellerId("RESELLER001")           // 经销商ID（必填）
    .paymentAmount(new BigDecimal("10000.00"))  // 支付金额（必填）
    .currency("CNY")                     // 币种（可选，默认CNY）
    .paymentType(PaymentType.ADVANCE_PAYMENT)  // 支付类型（必填）
    .paymentDeadline(LocalDateTime.now().plusDays(7))  // 支付截止时间（可选）
    .businessDesc("订单预付款")           // 业务描述（可选）
    .createBy("SYSTEM")                  // 创建人ID（必填）
    .createByName("系统")                 // 创建人姓名（必填）
    .build();
```

#### 返回值
- 类型：`PaymentAggregate`
- 包含字段：
  - `code`: 支付单号（系统生成）
  - `paymentStatus`: 支付状态（初始为UNPAID）
  - `refundStatus`: 退款状态（初始为NO_REFUND）
  - 其他支付单信息

#### 事件发布
- **事件名称**: `PaymentCreatedEvent`
- **订阅方**: 订单系统、财务系统等
- **事件内容**: 支付单号、订单号、经销商ID、支付金额等

#### 使用示例

**订单系统调用示例**:
```java
@Service
public class OrderService {
    
    @Autowired
    private IPaymentInternalService paymentInternalService;
    
    public void createOrder(Order order) {
        // 1. 创建订单逻辑
        // ...
        
        // 2. 创建支付单
        CreatePaymentCommand command = CreatePaymentCommand.builder()
                .orderId(order.getOrderNo())
                .resellerId(order.getResellerId())
                .paymentAmount(order.getTotalAmount())
                .paymentType(PaymentType.ADVANCE_PAYMENT)
                .paymentDeadline(order.getPaymentDeadline())
                .businessDesc("订单预付款")
                .createBy(order.getCreatorId())
                .createByName(order.getCreatorName())
                .build();
        
        PaymentAggregate payment = paymentInternalService.createPayment(command);
        
        // 3. 记录支付单号到订单
        order.setPaymentCode(payment.getCode());
    }
}
```

**信用管理系统创建信用还款支付单示例**:
```java
@Service
public class CreditService {
    
    @Autowired
    private IPaymentInternalService paymentInternalService;
    
    public void createCreditRepaymentPayment(CreditRecord creditRecord) {
        CreatePaymentCommand command = CreatePaymentCommand.builder()
                .orderId(creditRecord.getOrderNo())
                .resellerId(creditRecord.getResellerId())
                .paymentAmount(creditRecord.getRepaymentAmount())
                .paymentType(PaymentType.CREDIT_REPAYMENT)  // 信用还款类型
                .relatedBusinessId(creditRecord.getId())     // 关联信用记录ID
                .relatedBusinessType(RelatedBusinessType.CREDIT_RECORD)
                .businessExpireDate(creditRecord.getDueDate())
                .businessDesc("信用还款")
                .createBy("CREDIT_SYSTEM")
                .createByName("信用系统")
                .build();
        
        PaymentAggregate payment = paymentInternalService.createPayment(command);
    }
}
```

---

### 2.2 执行退款接口

#### 接口定义
```java
public interface IPaymentInternalService {
    /**
     * 执行退款
     * @param command 执行退款命令
     * @return 退款流水号
     */
    String executeRefund(ExecuteRefundCommand command);
}
```

#### 使用场景
- **订单系统**：退款审批通过后，调用此接口执行退款

#### 参数说明

**ExecuteRefundCommand**:
```java
ExecuteRefundCommand.builder()
    .refundOrderId("REFUND123456")       // 退款单号（订单系统的退款单号，必填）
    .paymentId("PAY_DB_ID_123")          // 支付单ID（数据库主键，必填）
    .refundAmount(new BigDecimal("5000.00"))  // 退款金额（必填）
    .refundReason("客户取消订单")         // 退款原因（必填）
    .originalTransactionId("TXN_ID_456") // 原支付流水ID（必填）
    .approvalInfo("{...}")               // 审批信息JSON（可选）
    .refundType("PARTIAL")               // 退款类型（可选）
    .build();
```

#### 返回值
- 类型：`String`
- 内容：退款流水号

#### 事件发布
- **事件名称**: `RefundExecutedEvent`
- **订阅方**: 订单系统、财务系统等
- **事件内容**: 支付单号、订单号、退款流水号、退款金额等

#### 使用示例

**订单系统调用退款示例**:
```java
@Service
public class RefundService {
    
    @Autowired
    private IPaymentInternalService paymentInternalService;
    
    public void processRefund(RefundOrder refundOrder) {
        // 1. 退款审批通过
        // ...
        
        // 2. 查询原支付单和支付流水
        String paymentId = getPaymentIdByOrderNo(refundOrder.getOrderNo());
        String originalTransactionId = getOriginalTransactionId(paymentId);
        
        // 3. 执行退款
        ExecuteRefundCommand command = ExecuteRefundCommand.builder()
                .refundOrderId(refundOrder.getRefundNo())
                .paymentId(paymentId)
                .refundAmount(refundOrder.getRefundAmount())
                .refundReason(refundOrder.getReason())
                .originalTransactionId(originalTransactionId)
                .approvalInfo(buildApprovalInfo(refundOrder))
                .build();
        
        String refundTransactionId = paymentInternalService.executeRefund(command);
        
        // 4. 记录退款流水号
        refundOrder.setRefundTransactionId(refundTransactionId);
    }
}
```

---

## 3. 外部REST接口

### 3.1 批量支付接口

#### 接口定义
- **HTTP方法**: POST
- **路径**: `/api/v1/payments/batch-pay`
- **Content-Type**: application/json

#### 使用场景
- 经销商在前端选择多个待支付支付单，进行合并支付

#### 请求参数

**Header**:
```
X-Reseller-Id: RESELLER001  (可选，实际应从认证上下文获取)
```

**Request Body (BatchPaymentExecuteRO)**:
```json
{
  "paymentItems": [
    {
      "paymentCode": "PAY202501150001",
      "amount": 5000.00
    },
    {
      "paymentCode": "PAY202501150002",
      "amount": 3000.00
    }
  ],
  "paymentChannel": "ONLINE_PAYMENT"
}
```

#### 响应结果

**Response Body (BatchPaymentResultVO)**:
```json
{
  "channelTransactionNumber": "CHN_TXN_202501150001",
  "totalAmount": 8000.00,
  "paymentCount": 2,
  "paymentResults": [
    {
      "paymentCode": "PAY202501150001",
      "amount": 5000.00,
      "transactionId": "TXN_ID_001",
      "success": true,
      "errorMessage": null
    },
    {
      "paymentCode": "PAY202501150002",
      "amount": 3000.00,
      "transactionId": "TXN_ID_002",
      "success": true,
      "errorMessage": null
    }
  ]
}
```

#### 前端调用示例

**JavaScript/TypeScript**:
```typescript
// 批量支付请求
async function batchPayment(paymentItems: PaymentItem[], channel: string) {
  const response = await fetch('/api/v1/payments/batch-pay', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-Reseller-Id': 'RESELLER001'  // 实际从用户认证信息获取
    },
    body: JSON.stringify({
      paymentItems: paymentItems,
      paymentChannel: channel
    })
  });
  
  if (!response.ok) {
    throw new Error('批量支付失败');
  }
  
  const result = await response.json();
  console.log('渠道交易号:', result.channelTransactionNumber);
  console.log('支付总金额:', result.totalAmount);
  return result;
}

// 使用示例
const items = [
  { paymentCode: 'PAY202501150001', amount: 5000.00 },
  { paymentCode: 'PAY202501150002', amount: 3000.00 }
];

batchPayment(items, 'ONLINE_PAYMENT')
  .then(result => {
    // 处理成功
    showSuccess('支付已提交，渠道交易号: ' + result.channelTransactionNumber);
  })
  .catch(error => {
    // 处理失败
    showError('支付失败: ' + error.message);
  });
```

---

### 3.2 查询可用支付渠道接口

#### 接口定义
- **HTTP方法**: GET
- **路径**: `/api/v1/payments/available-channels`

#### 使用场景
- 前端在支付页面，显示当前经销商可用的支付渠道列表

#### 请求参数

**Header**:
```
X-Reseller-Id: RESELLER001  (可选，实际应从认证上下文获取)
```

#### 响应结果

**Response Body (List<PaymentChannelVO>)**:
```json
[
  {
    "channelCode": "ONLINE_PAYMENT",
    "channelName": "线上支付",
    "channelDescription": "Online Payment",
    "available": true,
    "unavailableReason": null
  },
  {
    "channelCode": "WALLET_PAYMENT",
    "channelName": "钱包支付",
    "channelDescription": "Wallet Payment",
    "available": true,
    "unavailableReason": null
  },
  {
    "channelCode": "WIRE_TRANSFER",
    "channelName": "电汇支付",
    "channelDescription": "Wire Transfer",
    "available": false,
    "unavailableReason": "您暂无使用该渠道的权限"
  },
  {
    "channelCode": "CREDIT_ACCOUNT",
    "channelName": "信用账户",
    "channelDescription": "Credit Account",
    "available": true,
    "unavailableReason": null
  }
]
```

#### 前端调用示例

**JavaScript/TypeScript**:
```typescript
// 查询可用支付渠道
async function getAvailableChannels() {
  const response = await fetch('/api/v1/payments/available-channels', {
    method: 'GET',
    headers: {
      'X-Reseller-Id': 'RESELLER001'  // 实际从用户认证信息获取
    }
  });
  
  if (!response.ok) {
    throw new Error('查询支付渠道失败');
  }
  
  const channels = await response.json();
  return channels.filter(c => c.available);  // 只返回可用的渠道
}

// 使用示例
getAvailableChannels()
  .then(channels => {
    // 渲染支付渠道选择列表
    renderChannelList(channels);
  })
  .catch(error => {
    showError('查询支付渠道失败: ' + error.message);
  });

// 渲染渠道列表示例
function renderChannelList(channels) {
  const container = document.getElementById('channel-list');
  channels.forEach(channel => {
    const item = document.createElement('div');
    item.className = 'channel-item';
    item.innerHTML = `
      <input type="radio" name="channel" value="${channel.channelCode}">
      <label>${channel.channelName}</label>
      <span class="description">${channel.channelDescription}</span>
    `;
    container.appendChild(item);
  });
}
```

---

## 4. 使用示例

### 4.1 完整的支付流程示例

#### 场景：订单创建 → 支付单创建 → 批量支付 → 支付回调

**步骤1：订单系统创建订单并创建支付单（内部调用）**
```java
// 订单系统代码
@Service
public class OrderService {
    @Autowired
    private IPaymentInternalService paymentInternalService;
    
    public Order createOrder(OrderCreateRequest request) {
        // 创建订单
        Order order = new Order();
        order.setOrderNo(generateOrderNo());
        order.setResellerId(request.getResellerId());
        order.setTotalAmount(request.getTotalAmount());
        // ... 其他订单信息
        
        // 创建支付单（内部接口）
        CreatePaymentCommand command = CreatePaymentCommand.builder()
                .orderId(order.getOrderNo())
                .resellerId(order.getResellerId())
                .paymentAmount(order.getTotalAmount())
                .paymentType(PaymentType.ADVANCE_PAYMENT)
                .createBy(request.getUserId())
                .createByName(request.getUserName())
                .build();
        
        PaymentAggregate payment = paymentInternalService.createPayment(command);
        order.setPaymentCode(payment.getCode());
        
        // 保存订单
        orderRepository.save(order);
        
        return order;
    }
}
```

**步骤2：前端查询可用支付渠道**
```javascript
// 前端代码
async function loadPaymentPage(orderNo) {
  // 1. 查询订单和支付单信息
  const order = await fetchOrder(orderNo);
  const payments = await fetchPaymentsByOrder(orderNo);
  
  // 2. 查询可用支付渠道
  const channels = await getAvailableChannels();
  
  // 3. 渲染支付页面
  renderPaymentPage(order, payments, channels);
}
```

**步骤3：前端提交批量支付**
```javascript
// 前端代码
async function submitPayment() {
  // 1. 获取选中的支付单
  const selectedPayments = getSelectedPayments();
  
  // 2. 获取选中的支付渠道
  const selectedChannel = getSelectedChannel();
  
  // 3. 构建批量支付请求
  const paymentItems = selectedPayments.map(p => ({
    paymentCode: p.code,
    amount: p.amount
  }));
  
  // 4. 提交批量支付
  const result = await batchPayment(paymentItems, selectedChannel);
  
  // 5. 显示结果
  showSuccess('支付已提交，请等待支付结果');
  redirectToPaymentResult(result.channelTransactionNumber);
}
```

**步骤4：支付渠道回调处理（系统内部）**
```java
// 支付模块代码
@Service
public class PaymentCallbackService {
    
    public void handlePaymentCallback(ChannelCallback callback) {
        // 1. 验证回调签名
        // 2. 查找支付流水
        // 3. 更新流水状态
        // 4. 更新支付单状态
        // 5. 发布支付成功事件（订单系统订阅此事件）
    }
}
```

---

### 4.2 完整的退款流程示例

#### 场景：订单退款审批 → 执行退款 → 退款回调

**步骤1：订单系统审批通过后执行退款（内部调用）**
```java
// 订单系统代码
@Service
public class RefundService {
    @Autowired
    private IPaymentInternalService paymentInternalService;
    
    public void approveRefund(RefundOrder refundOrder) {
        // 1. 审批通过
        refundOrder.setStatus(RefundStatus.APPROVED);
        refundOrderRepository.save(refundOrder);
        
        // 2. 查询原支付单
        String paymentId = getPaymentIdByOrderNo(refundOrder.getOrderNo());
        String originalTransactionId = getOriginalTransactionId(paymentId);
        
        // 3. 执行退款（内部接口）
        ExecuteRefundCommand command = ExecuteRefundCommand.builder()
                .refundOrderId(refundOrder.getRefundNo())
                .paymentId(paymentId)
                .refundAmount(refundOrder.getRefundAmount())
                .refundReason(refundOrder.getReason())
                .originalTransactionId(originalTransactionId)
                .build();
        
        String refundTransactionId = paymentInternalService.executeRefund(command);
        
        // 4. 记录退款流水号
        refundOrder.setRefundTransactionId(refundTransactionId);
        refundOrderRepository.save(refundOrder);
    }
}
```

**步骤2：支付模块处理退款回调**
```java
// 支付模块代码
@Service
public class RefundCallbackService {
    
    public void handleRefundCallback(ChannelCallback callback) {
        // 1. 验证回调签名
        // 2. 查找退款流水
        // 3. 更新流水状态
        // 4. 更新支付单退款状态
        // 5. 发布退款成功事件（订单系统订阅此事件）
    }
}
```

---

## 5. 注意事项

### 5.1 内部接口使用注意事项
1. **依赖注入**：通过Spring的`@Autowired`注入`IPaymentInternalService`
2. **事务管理**：内部接口已包含`@Transactional`，调用方无需额外处理事务
3. **异常处理**：捕获并处理`PaymentException`和其他业务异常
4. **事件订阅**：如需接收支付/退款事件，实现Spring的`ApplicationListener`

### 5.2 外部接口使用注意事项
1. **认证授权**：实际生产环境应从认证上下文获取经销商ID，不依赖请求头
2. **参数验证**：前端应进行基本参数验证，后端会进行完整验证
3. **异步结果**：批量支付接口是异步的，最终结果需要等待支付渠道回调
4. **错误处理**：前端应正确处理HTTP状态码和错误响应

### 5.3 安全建议
1. 支付单创建接口（`POST /api/v1/payments/`）已标记为废弃，不应使用
2. 批量支付接口应实施严格的权限验证
3. 所有金额计算应使用`BigDecimal`，避免精度问题
4. 支付渠道回调必须验证签名，防止伪造

---

## 6. 相关文档

- [payment.yml v2.0](./payment.yml) - DDD设计规范文档
- [支付模块需求设计文档 v1.5](./支付模块需求设计.md) - 需求设计文档
- [支付模块用例模型文档 v1.0](./支付模块用例模型.md) - 用例模型文档
- [全局术语表 v3.0](../Glossary.md) - 术语定义文档
